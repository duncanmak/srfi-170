<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI 170: POSIX API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>

  <body>

<h1>Title</h1>

POSIX API

<h1>Authors</h1>

Olin Shivers (original author), John Cowan (editor and shepherd)

<h1>Status</h1>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a
    href="https://srfi.schemers.org/srfi-process.html">an
    explanation</a> of each status that a SRFI can hold.  To provide
    input on this SRFI, please send email to <code><a
    href="mailto:srfi+minus+170+at+srfi+dotschemers+dot+org">srfi-170@<span
    class="antispam">nospam</span>srfi.schemers.org</a></code>.  To
    subscribe to the list, follow <a
    href="https://srfi.schemers.org/srfi-list-subscribe.html">these
    instructions</a>.  You can access previous messages via the
    mailing list <a
    href="https://srfi-email.schemers.org/srfi-170">archive</a>.</p>

<ul>
  <li>Received: 2019/5/4</li>
  <li>60-day deadline: 2019/7/5</li>
  <li>Draft #1 published: 2019/5/6</li>
  <li>Draft #2 published: 2019/5/10</li>
  <li>Draft #3 published: 2019/5/15</li>
  <li>Draft #4 published: 2019/6/20</li>
  <li>Draft #5 published: 2019/7/2</li>
</ul>


<h1>Abstract</h1>

<p>
The host environment is the set of resources, such as the filesystem,
network and processes, that are managed by the operating system on top of
which a Scheme program is executing. This SRFI specifies how the host
environment can be accessed from within a Scheme program.  It does so by
leveraging widespread support for P<small>OSIX</small>, the Portable
Operating System Interface standardized by the IEEE.  Not all of the
functions of this SRFI are available on all operating systems.
</p>

<h1>Issues</h1>

<ol>
  <li>Candidates for additional procedures from the Python <code>os</code> module:
    <code>pathconf</code>, <code>sysconf</code>, <code>statvfs</code>,
    <code>posix_fallocate</code>, <code>posix_fadvise</code>,
    <code>readv</code>, <code>writev</code>, <code>sendfile</code>,
    <code>sched_{get,set}scheduler</code> and friends.
    None are provided by scsh.</li>
  <li>(Resolved)</li>
  <li>(Resolved)</li>
</ol>

<h1>Rationale</h1>

<p>The I/O and other environmental procedures provided by the various
Scheme standards were designed at a time when operating systems were far
more diverse than they are today, and therefore portability was difficult
or impossible to achieve.  In addition, Scheme has historically focused
on programming-language features rather than the practical needs of
mainstream software development.  Consequently, none of the standards
provide more than a limited set of operations.  Individual implementations
often provide much more, but in incompatible ways.</p>

<p>This SRFI uses the IEEE 1003 P<small>OSIX</small>.1-2017 standard
to provide maximally portable
access to the services of the operating system on which typical Scheme
implementations run.  Almost all operating systems today support all
or part of P<small>OSIX</small>, so the use of this SRFI is mostly
portable, but implementations are definitely not portable.  However,
an implementation of this SRFI can be layered over many existing
implementation-specific interfaces, or directly over a C FFI.  It is
even possible to implement it on top of the JVM or CLR virtual
machines.
</p>

<p>
This SRFI describes a specific P<small>OSIX</small> API for Scheme.
Rather than attempting to compromise between existing implementations,
the scsh system call specification was chosen as a base document.
Consequently, this SRFI is a reduced version of
<a href="https://scsh.net/docu/html/man-Z-H-4.html#node_chap_3">Chapter 3, "System Calls"</a>
of version 0.6.7 of the <i>Scsh Reference Manual</i>.
The numbered headers are aligned with those used in the Reference Manual.
</p>
<p>Scsh 0.6.7 was chosen for two main reasons.  It is fairly old, so most of its operations,
even those which were non-Posix at the time (2006) are now included in Posix, and it has
few or no operations that aren't Posix at all.  In addition, it is politically fairly neutral,
being tied to an obsolete version of Scheme 48, which is not being actively developed.
There is an updated version on Github, which has been patched to work with the latest (2006)
version of Scheme 48.
</p>
<p>
This SRFI makes no effort to provide all 81 headers, 1191 interfaces, and 51
data types of full P<small>OSIX</small>.  Instead it provides a reasonable number of
highly portable interfaces (many of them even available on Windows)
with wrappers to make them more Scheme-like.
In particular, this SRFI excludes:
</p>
<ul>
<li><p>Most operations on ports and file descriptors
  other than converting between them.  For such operations, see SRFI FIXME,
  which is currently in pre-SRFI format at
  <a href="https://bitbucket.org/cowan/r7rs-wg1-infra/src/default/FilesAdvancedCowan.md">
    https://bitbucket.org/cowan/r7rs-wg1-infra/src/default/FilesAdvancedCowan.md</a>.
</p></li><li><p>
Networking operations: see
<a href="http://srfi.schemers.org/srfi-106/srfi-106.html">SRFI 106</a>.
</p></li><li><p>
Date and time operations, as the
P<small>OSIX</small> date and time operations are irregular and awkward.
This SRFI provides only the current timezone and locale.
</p></li><li><p>
Access to command-line arguments and environment variables, as well
as provisions for exiting a process, as they are already provided by R7RS.
</p></li><li><p>
P<small>OSIX</small> file locking, which is notoriously broken as
designed.  Consider the use of dot files (or if necessary
non-portable facilities) instead.
</p></li><li><p>
All provisions for signal handling, as they are complex and require deep
integration with the Scheme implementation.
</p></li><li><p>
Memory-mapped I/O, locales, syslog, System V message
queues, and pseudo-TTYs, as they are considered specialized and out of scope.
</p></li>
</ul>
<p>
Future SRFIs may provide interfaces for them.
</p>
<p>
The use of colons to join record names and fields into the name of a
record accessor is a convention of Scheme 48, on which scsh is built.
</p>

<h1>Specification</h1>

<p>
Implementations of this SRFI on non-P<small>OSIX</small> systems, especially Windows,
must provide all the procedure names and syntax keywords.
However, if the specified action is not possible, the procedure should
either take no action and return some reasonable default value,
or raise an <code>errno-error</code> exception.
</p>
<p>A Scheme implementation that supports both this SRFI and multiple
threads of control must ensure that when a thread invokes a blocking I/O
procedure defined below, only that thread is blocked and not any other
concurrently running ones.
</p>

<p>
</p>
<a name="node_sec_3.1"></a>
<h2><a href="#node_toc_node_sec_3.1">3.1&nbsp;&nbsp;Errors</a></h2>
<p>This SRFI's procedures never return error codes, and do not use a global
<code>errno</code> variable to report errors.
Errors are consistently reported by raising exceptions.
In addition, this SRFI requires that no error
based on the error code EINTR is ever raised.  Instead, the system call
that failed is retried.  This means that if a system call is interrupted
because a signal was received by the process, the system call will be
automatically retried, thus eliminating what is traditionally known as
<a href="https://www.dreamsongs.com/RiseOfWorseIsBetter.html">
the PC loser-ing problem<a/>.
</p><p>
This frees up the procedures to return useful values,
and allows the programmer to assume that
<i>if a procedure returns, it succeeded.</i>
This greatly simplifies the flow of the code from the programmer's point
of view.
</p><p>
For reference purposes, the P<small>OSIX</small> <code>errno</code> numbers
are bound to the variables <code>errno/perm</code>, <code>errno/noent</code>, etc.
See <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html">
the P<small>OSIX</small> specification of <code>errno.h</code></a> for the complete list.
<p>
</p>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(errno-error <i>errno procedure . data</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Raises a non-continuable exception for P<small>OSIX</small> error number <i>errno</i>.
The <i>procedure</i> and <i>data</i> arguments are packaged up in the exception
packet passed to the exception handler.
It is an error to pass an <code>errno</code> that is not provided by the OS.</p>
</blockquote><p>
</p>
<div align="left"><code>(syscall-error? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
  Returns <code>#t</code> if <i>obj</i> is an object created by a call to <code>errno-error</code>
  or one of an implementation-defined set of other objects, and <code>#f</code> otherwise.
</blockquote><p>
</p>
<div align="left"><code>(syscall-error:errno <i>syscall-error</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(syscall-error:message <i>syscall-error</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(syscall-error:procedure <i>syscall-error</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>procedure</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(syscall-error:data <i>syscall-error</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>list</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
  Returns a value equal to the Posix error number,
  the corresponding error message as determined by the Posix interface <code>strerror()</code>,
  the procedure passed to <code>errno-error</code>,
  and  a list containing the data packaged in in the <i>syscall-error</i> object respectively.
  All of these, with the possible exception of the error message, are
  packaged in the <i>syscall-error</i> object.
  It is an error to mutate the values returned by any of these procedures.
</blockquote><p>
</p>
<a name="node_sec_3.2"></a>
<h2><a href="#node_toc_node_sec_3.2">3.2&nbsp;&nbsp;I/O</a></h2>
<p></p>
<p>Dealing with P<small>OSIX</small> file descriptors in a Scheme environment is difficult.
In P<small>OSIX</small>, open files are part of the process environment, and are referenced
by small exact integers called <i>file descriptors</i>. Open file descriptors are
the fundamental way I/O redirections are passed to subprocesses and executed
programs, since file descriptors are preserved across <code>fork</code> and
<code>exec</code> operations.</p>
<p>
Scheme, on the other hand, uses ports for specifying I/O sources. Ports are
garbage-collected Scheme objects, not integers.
When a port is garbage collected, it is effectively closed,
but whether the underlying file descriptor is closed is left as an implementation detail.
Because file
descriptors are just integers, it's impossible to garbage collect them &mdash; you
wouldn't be able to close file descriptor 3 unless there were no 3's in the
system, and you could further prove that your program would never again
compute a 3. This is difficult at best.</p>
<p>
If a Scheme program only used Scheme ports, and never actually used
file descriptors, this would not be a problem. But Scheme code
needs to descend to the file descriptor level in at least two circumstances:
when interfacing to foreign code, and
when interfacing to a subprocess.
</p><p>
This causes a problem. Suppose we have a Scheme port constructed
on top of file descriptor 3. We intend to execute a successor program that
will expect this file descriptor. If we drop references to the port,
the garbage collector may prematurely close file 3 before we fork
the subprocess.</p>
<p>
Unfortunately, there is no even vaguely portable solution to this problem.
Scsh and Guile undertake heroic measures to
open new file descriptors for ports when the old file descriptors are
repurposed for something else, and to track when closing a port implies
closing its file descriptor or not.
But doing so involves more
changes than an implementation should have to make in order
to provide this SRFI.</p>

<p>Consequently, this SRFI assumes that file descriptors will only
be used at the edges of the program, and that most I/O operations will be
performed on ports.</p>
  
<p>The following routines allow conversion between ports and file
descriptors.</p>
<div align="left"><code>(fdes->textual-input-port <i>fd</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(fdes->binary-input-port <i>fd</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(fdes->textual-output-port <i>fd</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(fdes->binary-output-port <i>fd</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<p>These procedures wrap a newly created port around the specified file descriptor,
effectively importing it into the Scheme world.
In particular, the textual ports use the same encoding applied
by default in the underlying implemenation.</p>
</blockquote>

<div align="left"><code>(port-fdes <i>port</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure exposes the file descriptor of a port,
effectively exporting it from the Scheme world.
Alternatively, <code>#f</code> is returned if <i>port</i> does not have a
file descriptor (a string port, e.g.).
</blockquote><p>
</p>
<div align="left"><code>(dup->fdes <i>port [fd]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure replicates the file descriptor that underlies
<i>port</i> onto another file descriptor.
This allows what is open on <i>port</i> to be exported from the Scheme
world in such a way that the port and the file descriptor can be
manipulated semi-independently (although they will still share the
same file pointer and other things).
If the particular file descriptor to be used is important,
as before doing a <code>spawn</code> or <code>fork</code>, then
it can be specified as the second argument.
Otherwise, an unused file descriptor will be selected.
In either case, the newly modified file descriptor is returned.
</p>
<p>If <i>fd</i> is a file descriptor underlying some existing
port, and operations have already been done on that port,
it is an error to perform further operations on it.</p>
</blockquote>
<div align="left"><code>(close-fdes <i>fd</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>undefined</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p></p>
<blockquote>
<p>Closes the file descriptor <i>fd</i>.</p>
<p>If <i>fd</i> is associated with a port, it is an error
to do any further operations on that port.
The same is true of calls to <code>close-port</code> on a file descriptor,
if the implementation permits them.
</p>
</blockquote>
<h2><a href="#node_toc_node_sec_3.3">3.3&nbsp;&nbsp;File system</a></h2>
<p>The following procedures allow access to the
computer's file system.
<p>
</p>
<p></p>
<p></p>
<div align="left"><code>(create-directory <i>fname [permission-bits override?]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(create-fifo <i>fname [permission-bits override?]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(create-hard-link <i>oldname newname [override?]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(create-symlink <i>oldname newname [override?]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>
These procedures create objects of various kinds in the file system.</p>
<p>
The <i>override?</i> argument controls the action if there is already an
object in the file system with the new name.
If it is <code>#f</code>, which is the default, then an
error is signaled.  If it is <code>#t</code>,
the old object is deleted with R7RS-small <code>delete-file</code>
or <code>delete-directory</code> as appropriate before
creating the new object.
The effect of passing any other value is
implementation-dependent.</p>
</p><p>
The <i>permission-bits</i> default to <code>#o777</code>, but are masked by the current umask.
<p>
</p><p>
If you try to create a hard or symbolic link
and <i>oldname</i> and <i>newname</i> refer to the same file, it is an error
(and your file may be destroyed).
</p></blockquote>
</td></tr></tbody></table>
<p></p>
<p></p>
<div align="left"><code>(delete-directory <i>fname</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This procedure deletes directories from the file system.
</p>
</blockquote><p>
</p>
<p></p>
<div align="left"><code>(set-file-mode <i>fname/port permission-bits</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(set-file-owner <i>fname/port uid</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(set-file-group <i>fname/port gid</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures set the permission bits, owner id, and group id of a
file, respectively.
The file can be specified by giving the file name, or either an
integer file descriptor or a port open on the file.
Setting file user ownership usually requires root privileges.
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(set-file-timespecs <i>fname [access-timespec mod-timespec]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure sets the access and modified times for the file
<i>fname</i> to the supplied values (see section&nbsp;<a href="#node_sec_3.10">3.10</a>
for this SRFI's representation of time).
If neither time argument is supplied, they are both taken to be
the current time. It is an error if exactly one time is provided.
If the procedure completes successfully, the file's time of last
status-change (<code>ctime</code>) is set to the current time.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(truncate-file <i>fname/port len</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>The specified file is truncated to <i>len</i> bytes in length.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(file-info <i>fname/port [chase?]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>file-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The <code>file-info</code> procedure
returns a file-info record containing everything
there is to know about a file. If the <i>chase?</i> flag is true
(the default), then the procedure chases symlinks and reports on
the files to which they refer. If <i>chase?</i> is false, then
the procedure checks the actual file itself, even if it's a symlink.
The <i>chase?</i> flag is ignored if the file argument is a file descriptor
or port.<p>
</blockquote>
<div align="left"><code>(file-info? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a file-info object and <code>#f</code> otherwise.
</blockquote>

<div align="left"><code>(file-info:device <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:inode <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:mode <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:nlinks <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:uid <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:gid <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:rdev <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:size <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:blksize <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:blocks <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:atime <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:mtime <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(file-info:ctime <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the device number, inode number, mode (permission bits),
number of hard links, user id, group id, device ID if file is special,
size in bytes, optimal blocksize for I/O, number of 512B blocks allocated,
last access time, last modification time, and
last change of status time stored in <i>file-info</i> respectively
(see section&nbsp;<a href="#node_sec_3.10">3.10</a>
for this SRFI's representation of time).
</blockquote>

</blockquote>
<p></p>
<div align="left"><code>(file-info-directory? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(file-info-fifo? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(file-info-regular? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(file-info-socket? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(file-info-special? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(file-info-symlink? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures are file-type predicates that test the
file type stored in <i>file-info</i>.
</blockquote>
<p>
This SRFI does not provide a special means for checking the
permission bits in a <code>file-info</code> record,
though they are available in <code>file-info:mode</code>.
There are several problems with such procedures.
First, there's an
atomicity issue. In between checking permissions for a file and then trying
an operation on the file, another process could change the permissions,
so a return value from these functions guarantees nothing. Second,
Posix special-cases permission checking with the uid is 0 (<code>root</code>)
&mdash; if the file exists, root is assumed to have the requested permission.
However, not even root can write a file that is on a read-only file system,
such as a CD-ROM.</p>
</blockquote>
<p></p>
<p></p>
<div align="left"><code>(directory-files <i>[dir dotfiles?]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a list of file names in directory <i>dir</i>,
which defaults to the current working directory.
The <i>dotfiles?</i> flag (default <code>#f</code>) causes dot files to be
included in the list.
Regardless of the value of <i>dotfiles?</i>, the two files <code>.</code> and
<code>..</code> are <i>never</i> returned.<p>
The directory <i>dir</i> is not prepended to each file name in the
result list. That is,
</p>
<blockquote><code>(directory-files "/etc")</code></blockquote>returns
<blockquote><code>("chown" "exports" "fstab" <code>...</code>)</code></blockquote><i>not</i>
<blockquote><code>("/etc/chown" "/etc/exports" "/etc/fstab" <code>...</code>)</code></blockquote>To use the file names in the returned list, the programmer can either manually
prepend the directory,
or change to the directory before using the file names.
</p>
</blockquote><p>
</p>
<div align="left"><code>(open-directory <i>dir</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>directory-object</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(read-directory <i>directory-object</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string or <code>#f</code></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(close-directory <i>directory-object</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
These functions implement a direct interface to the
<code>opendir()</code>/
<code>readdir()</code>/
<code>closedir()</code>
family of functions for processing directories.
</p><p>
The <code>open-directory</code> procedure opens the
directory with the specified pathname for reading, returning an opaque directory object.
Then <code>read-directory</code>
returns the name of the next available file
(including all files whose names begin with dot except for <code>.</code> and <code>..</code>, and
without <i>dir</i> present) in a <i>directory-object</i>,
or an end of file object if there are no more files.
Finally, <code>close-directory</code> closes a directory object.</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<div align="left"><code>temp-file-prefix</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string parameter</i>&nbsp;</div>
<p></p>
<blockquote>
A SRFI 39 or R7RS parameter that returns a string when invoked.  Its initial value is
the value of the environment variable <code>TMPDIR</code> concatenated with <code>"/<i>pid</i>"</code>
if <code>TMPDIR</code> is set and to
<code>"/tmp/<i>pid</i>"</code> otherwise, where <i>pid</i> is the id of the current process.
</blockquote>
<div align="left"><code>(create-temp-file <i>[prefix]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><code>Create-temp-file</code> creates a new temporary file and returns its name.
The optional argument specifies the filename prefix to use, and defaults
to the result of invoking <code>temp-file-prefix</code>.
The procedure generates a sequence of filenames that have <i>prefix</i> as
a common prefix, looking for a filename that doesn't already exist in the
file system. When it finds one, it creates it with permission <code>#o600</code>
and returns the filename. (The file permission can be changed to a more
permissive permission with <code>set-file-mode</code> after being created).<p>
This file is guaranteed to be brand new. No other process will have it
open. This procedure does not simply return a filename that is very
likely to be unused. It returns a filename that definitely did not exist
at the moment <code>create-temp-file</code> created it.</p>
<p>
It is not necessary for the process's pid to be a part of the filename
for the uniqueness guarantees to hold. The pid component of the default
prefix simply serves to scatter the name searches into sparse regions, so
that collisions are less likely to occur. This speeds things up, but does
not affect correctness.</p>
</blockquote><p>
</p>
<div align="left"><code>(temp-file-iterate <i>maker [prefix]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i><sup>+</sup></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure can be used to perform certain atomic transactions on
the file system involving filenames. Some examples:
<ul>
<li>Linking a file to a fresh backup temp name.
</li><li>Creating and opening an unused, secure temp file.
</li><li>Creating an unused temporary directory.
</li></ul><p></p>
<p>
This procedure uses <i>prefix</i> to generate a series of trial
file names.  <i>Prefix</i> is a string, and
defaults to the value of invoking <code>temp-file-prefix</code>.
File names are generated by
concatenating <i>prefix</i>
with a varying string.<p>
<i>Maker</i> is a procedure which is serially called on each file name
generated.  It must return at least one value; it may return multiple
values. If the first return value is <code>#f</code> or if <i>maker</i> raises the
<code>errno/exist</code> errno exception, <code>temp-file-iterate</code> will loop,
generating a new file name and calling <i>maker</i> again. If the first
return value is true, the loop is terminated, returning whatever value(s)
<i>maker</i> returned.</p>
<p>
After a number of unsuccessful trials, <code>temp-file-iterate</code> may give up
and signal an error.</p>
<p>
To rename a file to a temporary name:
</p>
<blockquote><code><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(create-hard-link&nbsp;old-file&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".temp.")&nbsp;;&nbsp;Keep&nbsp;link&nbsp;in&nbsp;cwd.<br>
(delete-file&nbsp;old-file)</code></blockquote>
Recall that this SRFI reports procedure failure by raising an error
exception, not by returning an error code. This is critical for
this example &mdash; the programmer can assume that if the
<code>temp-file-iterate</code> call returns, it returns successfully.
So the following <code>delete-file</code> call can be reliably invoked,
safe in the knowledge that the backup link has definitely been established.<p>
To create a unique temporary directory:
</p>
<blockquote><code><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(dir)&nbsp;(create-directory&nbsp;dir)&nbsp;dir)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/tmp/tempdir.")</code></blockquote>
Similar operations can be used to generate unique symlinks and fifos,
or to return values other than the new filename (<i>e.g.</i>, an open file
descriptor or port).<p>
For increased security, a user may wish to
change the template to use a directory not allowing world write
access (<i>e.g.</i>, his home directory).
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(real-path <i>path</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns an absolute pathname
derived from <i>pathname</i> that names the same file
and whose resolution does not involve <code>.</code>, <code>..</code>, or symbolic links.
</blockquote>
<a name="node_sec_3.4"></a>
<h2><a href="#node_toc_node_sec_3.4">3.4&nbsp;&nbsp;Processes</a></h2>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(spawn <i>mode</i> [<i>config</i>] prog arg</i><sub>1</sub> <code>...</code>arg</i><sub><i>n</i></sub></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(spawn-path <i>mode</i> [<i>config</i>] prog arg</i><sub>1</sub> <code>...</code><i>arg</i><sub><i>n</i></sub></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<p>
These procedures cause a new process to be created running
<i>prog</i>, passing it the specified arguments and environment.
Their C counterparts are part of a P<small>OSIX</small> extension
(they are easily defined if not provided), and also exist in Windows.
They may work even when a combination
of <code>fork</code> and <code>exec</code>
will not (as on Windows), and are therefore preferred in portable code
wherever possible.
</p>
<p>The <i>mode</i> argument is one of the values
<code>spawn/wait</code>, <code>spawn/nowait</code>,
or <code>spawn/detach</code>.
  <code>Spawn/wait</code> causes the procedure to wait until the new process
  terminates, and then returns its exit code as an exact integer
  (see <code>wait</code> for details).
  The other two values cause the procedure to return immediately
  with an unspecified object.  <code>Spawn/detach</code> will cause the new
  process to run detached from any control terminal; on Windows it will have no
  access to the terminal at all.
</p>
<p>The <i>config</i> argument is an optional plist
(a list of alternating symbols and values).
The symbols <code>arg0</code> and <code>env</code>
are defined by this SRFI;
the meaning of all other symbols is implementation-dependent.
They are meant to provide access to further variants of
the <code>spawn</code> functions
that are not standardized in this SRFI.
</p>
<p>
The value of the key <code>env</code> is a
string&rarr;string alist.
If omitted, the environment of the current
process is used.
(i.e., the value of the external char <code>**environ</code>).</p>
<p>
The value of the key <code>arg0</code> is a string
which is passed to the OS as the zeroth command-line
argument.
If omitted, <i>prog</i> is used as the zeroth argument,
which is normally the Right Thing.  Some operating systems
and programming languages discard the zeroth argument.
</p>
<p>
The <code>spawn-path</code> variant searches the directories in the
value of the environment variable <code>PATH</code>.
A path search is not performed if the program name contains
a slash character &mdash; it is used directly.
So a <i>prog</i> like <code>"bin/prog"</code>
always executes the program <code>bin/prog</code>
in the current working directory.
See also <code>exec-path-list</code> below.</p>
<p>Both of these procedures may flush buffered output
before creating the next process.
<p>
</blockquote>
</p><p>
<div align="left"><code>(file-spawn <i>file</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
    Opens an appropriate viewer or editor, depending on the OS,
    for <i>file</i>.  This is a system call on Windows, but can be
    done on Linux and MacOS by spawning the <code>xdg-open</code>
    and <code>open</code> programs respectively.  The procedure returns
    as soon as the application is launched with an unspecified value, so
    there is no access to the pid of the new process.</blockquote>
<p></p>
<p></p>
<div align="left"><code>(exec <i>prog <i>arg</i><sub>1</sub> <code>...</code><i>arg</i><sub><i>n</i></sub></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(exec-path <i>prog <i>arg</i><sub>1</sub> <code>...</code><i>arg</i><sub><i>n</i></sub></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<p>
These procedures do the same things as the corresponding <code>spawn</code> procedures,
except that no new process is created.  Instead, they cause the current program
to be replaced in the current process.
Consequently, these procedures never return under any circumstances.
As with any other procedure in this SRFI, if there is an error, they raise
an exception.
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(fork <i>[thunk or <code>#f</code>]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <code>#f</code></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>


<blockquote>
<code>fork</code> with no arguments or <code>#f</code> instead of a thunk is like
<code>fork()</code>.
In the parent process, it returns the child's <i>process object</i>
(see below for more information on process objects).  In the child
process, it returns <code>#f</code>.<p>
<code>fork</code> with an argument only returns in the parent process, returning
the child's process object.
The child process calls <i>thunk</i> and then exits.</p>
<p>
<code>fork</code> may or may not flush buffered output before forking.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
</p>
<a name="node_sec_3.4.1"></a>
<h3><a href="#node_toc_node_sec_3.4.1">3.4.1&nbsp;&nbsp;Process objects</a></h3>
<p>
This SRFI uses <i>process objects</i> to represent P<small>OSIX</small> processes.
They are created by the <code>fork</code> procedure, and
are opaque objects wrapping the pid of the process, the exact id
assigned by the kernel to the process.
No constructor is exposed, but any procedure that accepts a process object
also accepts a pid.
<div align="left"><code>(proc? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a process object and <code>#f</code> otherwise.
</blockquote>
<div align="left"><code>(proc:pid <i>proc</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the pid of <i>proc</i>.
</blockquote>
<a name="node_sec_3.4.2"></a>
<h3><a href="#node_toc_node_sec_3.4.2">3.4.2&nbsp;&nbsp;Process waiting</a></h3>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(wait <i>proc/pid [flags]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>status</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure waits until a child process exits, and returns its
exit code. The <i>proc/pid</i> argument is either a process object
(section <a href="#node_sec_3.4.1">3.4.1</a>) or an exact integer process id.
<code>Wait</code> returns the child's exit status code (or suspension code,
if the <code>wait/stopped-children</code> option is used; see below).
Status values can be queried with the procedures in section
<a href="#node_sec_3.4.3">3.4.3</a>.<p>
The <i>flags</i> argument is an exact integer whose bits specify
additional options. It is composed by adding together either or both of the
flags <code>wait/poll</code> and <code>wait/stopped-children</code>.
The first causes <code>wait</code> to return <code>#f</code> immediately if
a child is still active; the second causes <code>wait</code> to
wait for suspended as well as terminated children.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(wait-process-group <i>proc/pid [flags]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>[proc status]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure waits for any child whose process group is <i>proc/pid</i>
(either a process object or a pid).
The <i>flags</i> argument is as for <code>wait</code>.
</blockquote><p>
</p>
<a name="node_sec_3.4.3"></a>
<h3><a href="#node_toc_node_sec_3.4.3">3.4.3&nbsp;&nbsp;Analysing process status codes</a></h3>
<p>
When a child process dies (or is suspended), its parent can call the <code>wait</code>
procedure to recover the exit (or suspension) status of the child.
The exit status is a small exact integer that encodes information
describing how the child terminated.
The bit-level format of the exit status is not defined by P<small>OSIX</small>,
so use the following three functions to decode one.
However, if a child terminates normally with exit code 0,
P<small>OSIX</small> does require <code>wait</code> to return an exit status that is exactly
zero.
So <code>(zero? <i>status</i>)</code> is a correct way to test for non-error,
normal termination.
</p>
<p></p>
<div align="left"><code>(status:exit-val <i>status</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <code>#f</code></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(status:stop-sig <i>status</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <code>#f</code></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(status:term-sig <i>status</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <code>#f</code></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
For a given status value produced by calling <code>wait</code>,
exactly one of these routines will return a true value.<p>
If the child process exited normally, <code>status:exit-val</code> returns the
exit code for the child process (i.e., the value the child passed to <code>exit</code>
or returned from <code>main</code>). Otherwise, this function returns false.</p>
<p>
If the child process was suspended by a signal, <code>status:stop-sig</code>
returns the signal that suspended the child.
Otherwise, this function returns false.</p>
<p>
If the child process terminated abnormally, <code>status:term-sig</code>
returns the signal that terminated the child.
Otherwise, this function returns false.
</p>
</blockquote><p>
</p>
<p>
</p>
<p>
</p>
<a name="node_sec_3.5"></a>
<h2><a href="#node_toc_node_sec_3.5">3.5&nbsp;&nbsp;Process state</a></h2>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(umask<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(set-umask <i>perms</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The process's current umask is retrieved with <code>umask</code>, and set with
<code>(set-umask <i>perms</i>)</code>.
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(chdir <i>[fname]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(cwd<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These forms manipulate the current working directory.
The cwd can be changed with <code>chdir</code>.
If <code>chdir</code> is called with no arguments, it changes the cwd to
the user's home directory.
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(pid<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(parent-pid<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(process-group<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(set-process-group <i>[proc/pid] pgrp</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<code>(pid)</code> and <code>(parent-pid)</code> retrieve the process id for the
current process and its parent.
<code>(process-group)</code> returns the process group of the current process.
A process's process group can be set with <code>set-process-group</code>;
the value <i>proc/pid</i> specifies the affected process. It may be either
a process object or an exact integer process id, and defaults to the current
process.
</blockquote><p>
</p>
<p></p>
<p></p>
<div align=left><code>(set-priority <i>which who niceness</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align=left><code>(priority <i>which who</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
  <p>These procedures modify and access the niceness of processes.</p>
  <ul><li><p>The <i>which</i> argument is one of the constants <code>priority/process</code>,
  <code>priority/process-group</code>, or <code>priority/user</code>, indicating whether
  the priority of a single process, all processes in a process group, or all
  processes with the same effective uid are being set or retrieved.</li>
  <li><p>The <i>who</i> argument is the process object or pid, the process group, or the
  effective uid respectively.  If it is 0, the current pid, process group, or
  effective uid is used.</li>
  <li><p>The lower the <i>niceness</i> value is, the more the process is favored during scheduling.</li>
</ul>
  <p>Real-time processes are not affected by <code>set-priority</code>.</p>
</blockquote>
<div align=left><code>(nice <i>[proc/pid delta]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
  Increments the niceness of the single process specified by
  a process object or pid by <i>delta</i>.</p>
  <p>Real-time processes are not affected by <code>nice</code>.</p>
</blockquote><p>
</p>
<div align="left"><code>(user-login-name<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(user-uid<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(user-gid<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(user-supplementary-gids<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i> list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(set-uid <i>uid</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(set-gid <i>gid</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These routines get and set the effective and real user and group ids.
</blockquote><p>
</p>
<div align="left"><code>(user-effective-uid<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(set-user-effective-uid <i><i>exact integer</i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(user-effective-gid<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(set-user-effective-gid <i><i>exact integer</i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p>
</p>
<blockquote>
These forms manipulate the effective user/group IDs. Possible values
for setting this resource are either the real user/group ID or the
saved set-user/group-ID.
</blockquote><p>
</p>
<p></p>
<p></p>
<a name="node_sec_3.6"></a>
<h2><a href="#node_toc_node_sec_3.6">3.6&nbsp;&nbsp;User and group database access</a></h2>
<p>These procedures are used to access the user and group databases
(<i>e.g.</i>, the ones traditionally stored in <code>/etc/passwd</code> and <code>/etc/group</code>).</p>
<p>
</p>
<p></p>
<p></p>
<div align="left"><code>(user-info <i>uid/name</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <code>user-info</code> record giving the recorded information for a
particular user.
The <i>uid/name</i> argument is either an exact integer uid or a string user name.
</blockquote><p>
</p>
<p></p>
<div align="left"><code>(user-info? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a user info object and <code>#f</code> otherwise.
</blockquote>
<div align="left"><code>(user-info:name <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(user-info:uid <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(user-info:gid <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(user-info:home-dir <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(user-info:shell <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the user name, user id, group id, home directory,
and shell path stored in <i>user-info</i> respectively.</blockquote>
<p></p>
</p>
<p></p>
<p></p>
<div align="left"><code>(group-info <i>gid/name</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <code>group-info</code> record giving the recorded information for a
particular group.
The <i>gid/name</i> argument is either an exact integer gid or a string group name.
</blockquote>

<div align="left"><code>(group-info? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a group info object and <code>#f</code> otherwise.
</blockquote>
<div align="left"><code>(group-info:name <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(group-info:gid <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(group-info:members <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the group name, group id, and group member names
stored in <i>group-info</i> respectively.</blockquote>

</p>
<a name="node_sec_3.7"></a>
<h2><a href="#node_toc_node_sec_3.7">3.7&nbsp;&nbsp;[Intentionally omitted]</a></h2>
<a name="node_sec_3.8"></a>
<h2><a href="#node_toc_node_sec_3.8">3.8&nbsp;&nbsp;System parameters</a></h2>
<p></p>
<p></p>
<p></p>
<div align="left"><code>(system-name<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns the name of the host on which we are executing.
This may be a local name, such as "solar," as opposed to a
fully-qualified domain name such as "solar.csie.ntu.edu.tw."
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(uname<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>uname-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns a uname record.
</blockquote>

<div align="left"><code>(uname? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a uname record and <code>#f</code> otherwise.
</blockquote>

<div align="left"><code>(uname:os-name <i>uname</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(uname:node-name <i>uname</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(uname:release-name <i>uname</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(uname:version <i>uname</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(uname:machine <i>uname</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the OS name, node name, OS release name,
OS version, and machine name stored in <i>uname</i> respectively.
Each of the fields contains a string.
Be aware that P<small>OSIX</small> limits the length of all entries to 32 characters,
and that the node name does not necessarily correspond to the
fully-qualified domain name.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(current-timezone<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the current timezone as a string, or <code>#f</code> if it is not known.
</blockquote>

</blockquote><p>
</p>
<p></p>
<div align="left"><code>(current-locale<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the current locale as a string, or <code>#f</code> if it is not known.
</blockquote>

</blockquote><p>
</p>
<a name="node_sec_3.9"></a>
<h2><a href="#node_toc_node_sec_3.9">3.9&nbsp;&nbsp;Signal system</a></h2>
<p>This SRFI deals only with signaling other processes.
Signal <i>handling</i> is so complex and so intertwined
with the Scheme implementation that this SRFI
does not standardize it.</p>
<p>Signal numbers are bound to the variables <code>signal/hup</code>, <code>signal/int</code>, etc.
See <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html">
the P<small>OSIX</small> specification of <code>signal.h</code></a> for the complete list.
<p>
</p>
<p></p>
<p></p>
<div align="left"><code>(signal-process <i>proc sig</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><code>(signal-process-group <i>prgrp sig</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These two procedures send signals to a specific process and all the processes
in a specific process group, respectively.
The <i>proc</i> and <i>prgrp</i> arguments are either processes
or exact integer process ids.
</blockquote><p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_3.10"></a>
<h2><a href="#node_toc_node_sec_3.10">3.10&nbsp;&nbsp;Time</a></h2>
<div align=left><code>(posix-time)</code> &nbsp;&nbsp;&nbsp;&nbsp;---> &nbsp;&nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
<p>The <code>posix-time</code> procedure returns the current time as a
<i>timespec</i>, a pair whose car is the number of elapsed seconds
since the P<small>OSIX</small> epoch (midnight January 1, 1970 Universal
Time) excluding leap seconds, and whose cdr is the number of elapsed
nanoseconds since the beginning of the current second.  The system
clock is not required to report time at full nanosecond resolution,
nor is anything guaranteed about accuracy.
</blockquote>
</blockquote><p>
</p>
<div align=left><code>(monotonic-time)</code> &nbsp;&nbsp;&nbsp;&nbsp;---> &nbsp;&nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
<p>The same as <code>posix-time</code>, except that the epoch is arbitrary.
This epoch cannot change after the current
program begins to run.
It is guaranteed that a call to <code>monotonic-time</code>
cannot return a time earlier than a previous call to <i>monotonic-time</i>.
This is not guaranteed for <code>posix-time</code>
because the system's P<small>OSIX</small> clock
is sometimes turned either forward or backward.
</p>
</blockquote><p>
</p>
<div align="left"><code>(timespec-difference <i>timespec<sub>1</sub> timespec<sub>2</sub></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>timespec</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns a timespec that represents the difference in
seconds and nanoseconds between
<i>timespec<sub>1</sub></i> and
<i>timespec<sub>2</sub></i>.
</blockquote>
</p>
<p></p>
<div align="left"><code>(timespec=? <i>timespec<sub>1</sub> timespec<sub>2</sub></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>timespec</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Compares two timespecs for exact equality.
</blockquote>
</p>
<p></p>
<p>You can convert between a timespec and an inexact number of seconds with the expression
<blockquote>
<code>(+ (car <i>timespec</i>) (/ (cdr <i>timespec</i>) 1000000000.0))</code>
</blockquote>
and in the reverse direction with:
<blockquote>
<code>(let-values (((secs nanos))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(floor/ <i>seconds</i> 10E9))<br/>
&nbsp;&nbsp;(cons secs nanos))
</code> </blockquote>
In the case of P<small>OSIX</small> time,
some precision is unavoidably lost.</p>
</p>
<h2><a href="#node_toc_node_sec_3.11">3.11&nbsp;&nbsp;Environment variables</a></h2>
<p>Most support for environment variables is provided in R7RS-small.
</p>
<div align=left><code>exec-path-list</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> list</div>
<blockquote>
This variable contains the contents of the <code>PATH</code> environment variable as
a list of strings, where each string contains a single directory pathname.  It is an
error to change the value of this variable or
to mutate this list or any of the strings.
On Windows, the pathnames are separated by semicolons rather than by colons.
Changing the value of <code>PATH</code> may or may not not change the value
of this variable.  In any case, this SRFI provides no mechanism to change
the values of environment variables or to add new ones, operations which
may in any case fail if there is not enough space in the environment.
</blockquote>
<a name="node_sec_3.12"></a>
<h2><a href="#node_toc_node_sec_3.12">3.12&nbsp;&nbsp;Terminal device control</a></h2>
<p></p>
<p>
</p>
<p>
P<small>OSIX</small> provides a complete set of routines for manipulating terminal
devices &mdash; putting them in "raw" mode, changing and querying their
special characters, modifying their I/O speeds, and so forth.
However, now that terminal emulators have almost completely displaced
terminals, very little of this is useful except for directly
controlling serial-line hardware, which itself is increasingly rare.
Therefore, this SRFI provides only the functions that are still
in common use by command-line programs: the ability to turn echoing on and off, the
ability to suppress the recognition of interrupt, quit, and
suspend characters; and the ability to put a terminal into
raw mode, in which no characters are specially recognized.
</p>

<div align="left"><code>(tty? <i>port</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return true if the argument is a tty.
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(tty-file-name <i>port</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>port</i> must be open on a tty.
Return the file name of the tty.
</blockquote><p>
</p>
<p>The following procedures use <code>dynamic-wind</code> magic when executing
their <code>thunk</code> arguments; if the thunk's dynamic extent is escaped,
the action of the procedure is undone, but if the thunk's dynamic extent
is re-entered, the action of the procedure is re-enabled.</p>
<div align="left"><code>(with-raw-mode <i>port min time thunk</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>port</i> must be open on a tty.
The tty is set to raw mode during the dynamic execution of <code>thunk</code>
and then is restored to canonical ("cooked") mode.  The effect of the
  <i>min</i> and <i>time</i> arguments is that any reads done on the tty
  while raw mode is in effect will return to the caller after <i>min</i>
  bytes have been read or <i>time</i> seconds have elapsed, whichever
  comes first.
</blockquote><p>
</p>
<div align="left"><code>(without-echo <i>port thunk</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>port</i> must be open on a tty.
Echoing of input is disabled on the tty during the execution of <code>thunk</code>
and then is re-enabled.
</blockquote><p>
</p>
<div align="left"><code>(without-interrupt-chars <i>port thunk</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>port</i> must be open on a tty.
The detection of interrupt (^C), quit (^\), and suspend (^Z) characters
on the tty is disabled during the execution of <code>thunk</code> and then is re-enabled.
</blockquote><p>
</p>
<div align="left"><code>(open-control-tty <i>tty-name</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure opens terminal device <i>tty-name</i> as the process's
control terminal
(see the <code>termios</code> man page for more information on control terminals).
The <i>tty-name</i> argument is a filename such as <code>/dev/ttya</code>.
It is opened for both input and output.<p>
<p>
This procedure guarantees that it will make the opened terminal the
process's control terminal only if the process does not have
an assigned control terminal at the time of the call.
If the SRFI process already has a control terminal, the results are undefined.</p>
<p>
To arrange for the process to have no control terminal prior to calling
this procedure, use the <code>become-session-leader</code> procedure.</p>
<p>
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(become-session-leader<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This is the C <code>setsid()</code> call.
P<small>OSIX</small> job-control has a three-level hierarchy:
session/process-group/process.
Every session has an associated control terminal.
This procedure places the current process into a brand new session,
and disassociates the process from any previous control terminal.
You may subsequently use <code>open-control-tty</code> to open a new control
terminal.<p>
It is an error to call this procedure if the current process is already
a session leader.
One way to guarantee this is not the case is only to call this procedure
after forking.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(tty-process-group <i>port/fname</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div align="left"><code>(set-tty-process-group <i>port/fname pgrp</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This pair of procedures gets and sets the process group of a given
terminal.
</blockquote><p>
</p>
<p></p>
<p></p>
<div align="left"><code>(control-tty-file-name<i></i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the file name of the process's control tty.
</blockquote><p>
</p>
</p>
<p>
</p>
<p></p>
<p></p>

<h1>Implementation</h1>

<a href="https://scsh.net/">Scsh</a> version 0.7,
<a href="https://github.com/scheme/scsh">which can be found at GitHub in the scsh repository of scheme</a>
(see build notes <a href="https://github.com/scheme-requests-for-implementation/srfi-170">here</a>)),
constitutes an implementation of this SRFI, with the following exceptions and deviations:

<h3><a href="#node_imp_node_sec_3.1">3.1&nbsp;&nbsp;Errors</a></h3>
<ul>
<li><p>
  Scsh defines the procedure <code>syscall-error?</code> but unfortunately does not expose it.
  A syscall-error object in scsh is a list whose second, third, and fourth elements
  are the errno, the error message, and the procedure respectively,
  and whose remaining elements (if any) are the data passed to <code>errno-error</code>.
  Therefore, the procedures <code>syscall-error:errno</code>, <code>syscall-error:message</code>,
  <code>syscall-error:procedure</code>, and <code>syscall-error:data</code> can be defined as
  <code>cadr</code>, <code>caddr</code>, <code>cadddr</code>, and <code>cddddr</code> respectively.
</p></li>
<li><p>
It's likely that not all of the error and signal numbers supported
by P<small>OSIX</small> are available in scsh.
</p></li>
</ul>

<h3><a href="#node_imp_node_sec_3.2">3.2&nbsp;&nbsp;I/O</a></h3>
<ul>
<li><p>
Scsh does not distinguish between textual and binary ports,
so there are only two procedures to convert file descriptors to ports,
<code>fdes->inport</code> in place of <code>fdes->textual-inport-port</code>
and <code>fdes->binary-input-port</code>, and
<code>fdes->outport</code> in place of <code>fdes->textual-output-port</code>
and <code>fdes->binary-output-port</code>.
</p></li>
<li><p>The <code>port-fdes</code> procedure is called <code>port->fdes</code> in scsh.
The name was changed because the use of the arrow suggests a conversion of the
port to a file descriptor, which is not the case.
</p></li>
<li><p>There is no <code>close-fdes</code> procedure in scsh, as the standard <code>close-port</code>
procedure suffices.
</p></li>
</ul>

<h3><a href="#node_imp_node_sec_3.3">3.3&nbsp;&nbsp;File system</a></h3>
<ul>
<li><p>
The <code>create-directory</code>, <code>create-fifo</code>,
and <code>set-file-mode</code> procedures were changed in 0.7 to take
a file-mode record instead of traditional permission bits.  A work-around
is to manually set the mode of a file, and use
<code>file-info</code> and <code>file-info:mode</code> to get a record
with the desired permission bits.
</p></li>
<li><p>
When <code>create-hard-link</code> is asked to make a link across file systems,
rather than erroring it creates a copy of the file at <i>newname</i>.
</p></li>
<li><p>
<code>set-file-timespecs</code> is <code>set-file-times</code> in scsh,
and <code>access-timespec</code> and <code>mod-timespec</code> are rational numbers,
which are cooerced to exact integers, and treated as the number of elapsed seconds
since the POSIX epoch of midnight January 1, 1970.
</p></li>
<li><p>
The scsh file-info record <code>atime</code>, <code>mtime</code>, and <code>ctime</code>
fields are exact integers, the number of elapsed seconds since the POSIX epoch of midnight January 1, 1970.
It does not implement the <code>rdev</code>, <code>blksize</code>, and <code>blocks</code> fields.
</p></li>
<li><p>
The <code>open-directory</code>, <code>read-directory</code>, and <code>close-directory</code>
procedures are called <code>open-directory-stream</code> etc.  The <code>read-directory-stream</code>
functions returns <code>#f</code> at the end of the directory instead of
an end of file object.
</p></li>
<li><p>
Scsh does not support parameters, so <code>temp-file-prefix</code> does not exist.
Instead, there is a fluid variable named <code>*temp-file-template*</code> whose
value is as defined in this SRFI with <code>/var</code> added in front of <code>/tmp</code>,
and <code>"~a"</code> appended to it, e.g., <code>/var/tmp/6812~a</code>.
</p></li>
<li><p>
The scsh fluid variable <code>*temp-file-template*</code> described
above includes the substring "<code>~a</code>", which is required in
the optional <code><i>prefix</i></code> argument
to <code>temp-file-iterate</code> (the iteration strings are inserted
there with <code>format</code>, instead of being concatenated with
<code><i>prefix</i></code>).
If trying the &#34To rename a file to a temporary name&#34 example,
beware of the cross file system <code>create-hard-link</code> bug
mentioned above.
</p></li>
<li><p>
Scsh does not support the <code>real-path</code> procedure, but it would be trivial to add
it to the source by cloning <code>read-symlink</code> and making it invoke the P<small>OSIX</small>
<code>realpath()</code> function.
</p></li>
</ul>

<h3><a href="#node_imp_node_sec_3.4">3.4&nbsp;&nbsp;Processes</a></h3>
<ul>
<li><p>
Scsh does not provide the <code>spawn</code> functions, but they are easily provided using
<code>fork</code> and the corresponding <code>exec</code> procedures.
</p></li>
<li><p>
In scsh the <code>exec0</code> procedures are called <code>%exec</code> and accept the elements of
the argument vector as a list, including the zeroth argument.
</p></li>
</ul>

<h3><a href="#node_imp_node_sec_3.5">3.5&nbsp;&nbsp;Process state</a></h3>
<ul>
<li><p>
Scsh specifies, but does not implement, the procedures for getting or setting process priorities.
</p></li>
</ul>

<h3><a href="#node_imp_node_sec_3.6">3.6&nbsp;&nbsp;User and group database access</a></h3>

<h3><a href="#node_imp_node_sec_3.7">3.7&nbsp;&nbsp;[Intentionally omitted]</a></h3>

<h3><a href="#node_imp_node_sec_3.8">3.8&nbsp;&nbsp;System parameters</a></h3>

<h3><a href="#node_imp_node_sec_3.9">3.9&nbsp;&nbsp;Signal system</a></h3>

<h3><a href="#node_imp_node_sec_3.10">3.10&nbsp;&nbsp;Time</a></h3>
<ul>
<li><p>
  Scsh does not provide <code>posix-time</code>, but it is easily defined using the procedures
  <code>time+ticks</code> and <code>ticks/sec</code>.  The first returns two values, the Posix
  second and the subsecond time in ticks; the second procedure specifies how many ticks
  a second contains.  These are easily converted to seconds and nanoseconds.
</p></li>
<li><p>
  Scsh does not provide the <code>current-timezone</code> and <code>current-locale</code> functions.
  The first gets the value of the <code>TZ</code> environment variable, or failing that
  the contents of a OS-specific file such as <code>/etc/timezone</code> 
  or <code>/etc/localtime</code> or some other implementation-specific source.
  The second gets the value of the <code>LANG</code> environment variable,
  or failing that an OS-specific file such as <code>/etc/locale.conf</code>
  or <code>/etc/sysconfig/i18n</code> or some other implementation-specific source.
</p></li>
</ul>

<h3><a href="#node_imp_node_sec_3.11">3.11&nbsp;&nbsp;Environment variables</a></h3>

<h3><a href="#node_imp_node_sec_3.12">3.12&nbsp;&nbsp;Terminal device control</a></h3>
<ul>
<li><p>
  Scsh provides a complete set of <code>termios.h</code> operations, from which the
  <code>with-raw-mode</code>, <code>without-echo</code>, and <code>without-interrupt-chars</code>
  procedures can be implemented along the lines specified by the definitions.
  For <code>with-raw-mode</code>, it's important to preserve and restore the
  <code>eof</code> and <code>eol</code> control characters, as these may occupy the same
  memory locations in cooked mode as the <code>min</code> and <code>time</code> settings in raw mode.
</p></li>
</ul>


<h1>Acknowledgements</h1>

Thanks to Olin Shivers, <i>sine quo non</i>, and all the Scheme implementors
who have followed his work.  Thanks also to all the participants in the
SRFI mailing list.

<h1>Copyright</h1>
Copyright &copy; 2019 by John Cowan.

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

<p>
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

<p>This SRFI is derived from the documentation for
  <a href="https://scsh.net/">scsh</a>, whose copyright notice, from
  the <code>COPYING</code> file, is reprinted here:</p>

<blockquote>
  <p>Copyright (c) 1993-2003 Richard Kelsey and Jonathan Rees</p>
  <p>Copyright (c) 1994-2003 by Olin Shivers and Brian D. Carlstrom.</p>
  <p>Copyright (c) 1999-2003 by Martin Gasbichler.</p>
  <p>Copyright (c) 2001-2003 by Michael Sperber.</p>
  <p>All rights reserved.</p>
  <p>Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:</p>
  <ol><li>Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.</li>
  <li>Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.</li>
  <li>The name of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.</li>
  </ol>
  <p>THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></blockquote>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
